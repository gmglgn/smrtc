// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

contract SimpleSelfDrop {
    // Security
    error ReentrantCall();
    uint256 private _entered;
    modifier nonReentrant() {
        if (_entered == 1) revert ReentrantCall();
        _entered = 1;
        _;
        _entered = 0;
    }

    error NotOwner();
    error AlreadyClaimed();
    error InsufficientFunds();
    error ZeroAmount();

    event Claimed(address indexed account, uint256 amount);
    event AmountPerAddressChanged(uint256 oldAmount, uint256 newAmount);
    event Deposit(address indexed from, uint256 amount);
    event Withdraw(address indexed to, uint256 amount);

    address public owner;
    uint256 public amountPerAddress = 0.01 ether; // default
    mapping(address => bool) public claimed;

    constructor() { owner = msg.sender; }

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    receive() external payable { emit Deposit(msg.sender, msg.value); }

    function setAmountPerAddress(uint256 newAmount) external onlyOwner {
        if (newAmount == 0) revert ZeroAmount();
        emit AmountPerAddressChanged(amountPerAddress, newAmount);
        amountPerAddress = newAmount;
    }

    function claim() external nonReentrant {
        if (claimed[msg.sender]) revert AlreadyClaimed();
        if (address(this).balance < amountPerAddress) revert InsufficientFunds();
        claimed[msg.sender] = true;
        (bool ok, ) = msg.sender.call{value: amountPerAddress}("");
        require(ok, "ETH transfer failed");
        emit Claimed(msg.sender, amountPerAddress);
    }

    function withdrawExcess(address payable to, uint256 amount) external onlyOwner nonReentrant {
        (bool ok, ) = to.call{value: amount}("");
        require(ok, "ETH transfer failed");
        emit Withdraw(to, amount);
    }
}
